#ncinstancetop:=[[[[8],[3,8]],[[8,9],[1,2,8,9]]],3,9];
#cutVar_top:=[[[1,2],[1,2,4],[2,3],[2,3,5],[4,5],[6,7],[6,7,8],[7,9]],3,9];


#ncinstancetop:=[[[[1,2],[1,2,4]],[[2,3],[2,3,5]],[[6,7],[6,7,8]],[[7],[7,9]],[[8],[3,8]],[[8,9],[1,2,8,9]]],3,9];
#cutVar_top:=[[[1,2],[1,2,4],[2,3],[2,3,5],[4,5],[6,7],[6,7,8],[7,9]],3,9];

RemovezeroColumn := function(A)
local s,AT,ATnew;
AT :=  TransposedMat(A);
ATnew := [];
for s in AT do
    if Maximum(s) = 1 or Minimum(s) = -1 then
        Append(ATnew,[s]);
    fi;
od;
return TransposedMat(ATnew);
end;

  
  
GenShannonUnBounded_decomposed_removeZero:=function ( N1,N2,N3 ) #Calculate \Gamma_{N1\cup N3}\time \Gamma_{N2\cup N3}
  local  Ntop,ntop,Nbottom,nbottom,nwhole,rlist, mtx, str, i, j, shineq, 
  nset_i, ineq, pairsTop, pairsBottom, p, Klist, K, nset_ij, greq, neq, A, b, s;
  shineq := [  ];
  Ntop := Union(N1,N3);
  ntop := Size(Ntop);
  Nbottom := Union(N2,N3);
  nbotton := Size(Nbottom);
  nwhole := Size(N1) + Size(N2) + Size(N3);
  for i  in Ntop  do
      nset_i := ShallowCopy(Ntop);
      SubtractSet( nset_i, [ i ] );
      ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
      ineq[set2int( Ntop ) ] := 1;
      ineq[set2int( nset_i ) ] := -1;
      Append( shineq, [ ineq ] );
  od;
  for i  in Nbottom  do
      nset_i := ShallowCopy(Nbottom);
      SubtractSet( nset_i, [ i ] );
      ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
      ineq[set2int( Nbottom ) ] := 1;
      ineq[set2int( nset_i ) ] := -1;
      Append( shineq, [ ineq ] );
  od;
  pairsTop := Combinations( Ntop, 2 );
  for p  in pairsTop  do
      nset_ij := ShallowCopy(Ntop);
      SubtractSet( nset_ij, p );
      Klist := Combinations( nset_ij );
      for K  in Klist  do
          ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
          ineq[set2int( Union( K, [ p[1] ] ) ) ] := 1;
          ineq[set2int( Union( K, [ p[2] ] ) ) ] := 1;
          ineq[set2int( Union( K, p ) ) ] := -1;
          if Size( K ) > 0  then
              ineq[set2int( K ) ] := -1;
          fi;
          Append( shineq, [ ineq ] );
      od;
  od;
  pairsBottom := Combinations( Nbottom, 2 );
  for p  in pairsBottom  do
      nset_ij := ShallowCopy(Nbottom);
      SubtractSet( nset_ij, p );
      Klist := Combinations( nset_ij );
      for K  in Klist  do
          ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
          ineq[set2int( Union( K, [ p[1] ] ) ) ] := 1;
          ineq[set2int( Union( K, [ p[2] ] ) ) ] := 1;
          ineq[set2int( Union( K, p ) ) ] := -1;
          if Size( K ) > 0  then
              ineq[set2int( K ) ] := -1;
          fi;
          Append( shineq, [ ineq ] );
      od;
  od;
  shineq := - shineq;
  A := RemovezeroColumn(shineq);
  b := ZeroMutable([1..Size(A)]);
  return [ A, b ];
end;

GenShannonUnBounded_decomposed:=function ( N1,N2,N3 ) #Calculate \Gamma_{N1\cup N3}\time \Gamma_{N2\cup N3}
  local  Ntop,ntop,Nbottom,nbottom,nwhole,rlist, mtx, str, i, j, shineq, 
  nset_i, ineq, pairsTop, pairsBottom, p, Klist, K, nset_ij, greq, neq, A, b, s;
  shineq := [  ];
  Ntop := Union(N1,N3);
  ntop := Size(Ntop);
  Nbottom := Union(N2,N3);
  nbotton := Size(Nbottom);
  nwhole := Size(N1) + Size(N2) + Size(N3);
  for i  in Ntop  do
      nset_i := ShallowCopy(Ntop);
      SubtractSet( nset_i, [ i ] );
      ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
      ineq[set2int( Ntop ) ] := 1;
      ineq[set2int( nset_i ) ] := -1;
      Append( shineq, [ ineq ] );
  od;
  for i  in Nbottom  do
      nset_i := ShallowCopy(Nbottom);
      SubtractSet( nset_i, [ i ] );
      ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
      ineq[set2int( Nbottom ) ] := 1;
      ineq[set2int( nset_i ) ] := -1;
      Append( shineq, [ ineq ] );
  od;
  pairsTop := Combinations( Ntop, 2 );
  for p  in pairsTop  do
      nset_ij := ShallowCopy(Ntop);
      SubtractSet( nset_ij, p );
      Klist := Combinations( nset_ij );
      for K  in Klist  do
          ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1 ] );
          ineq[set2int( Union( K, [ p[1] ] ) ) ] := 1;
          ineq[set2int( Union( K, [ p[2] ] ) ) ] := 1;
          ineq[set2int( Union( K, p ) ) ] := -1;
          if Size( K ) > 0  then
              ineq[set2int( K ) ] := -1;
          fi;
          Append( shineq, [ ineq ] );
      od;
  od;
  pairsBottom := Combinations( Nbottom, 2 );
  for p  in pairsBottom  do
      nset_ij := ShallowCopy(Nbottom);
      SubtractSet( nset_ij, p );
      Klist := Combinations( nset_ij );
      for K  in Klist  do
          ineq := ZeroMutable( [ 1 .. 2 ^ nwhole - 1] );
          ineq[set2int( Union( K, [ p[1] ] ) ) ] := 1;
          ineq[set2int( Union( K, [ p[2] ] ) ) ] := 1;
          ineq[set2int( Union( K, p ) ) ] := -1;
          if Size( K ) > 0  then
              ineq[set2int( K ) ] := -1;
          fi;
          Append( shineq, [ ineq ] );
      od;
  od;
  shineq := - shineq;
  b := ZeroMutable([1..Size(shineq)]);
  return [ shineq, b ];
end;

NCShannonBounded_decomposition := function ( ncinstance, N1,N2,N3 )
    local  ShOB, i, linrows, con, conlin, j, conineq;
    ShOB := GenShannonUnBounded_decomposed( N1,N2,N3 );
    i := Size( ShOB[1] ) + 1;
    linrows := [  ];
    for con  in ncinstance[1]  do
        conlin := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 ] );
        conlin[set2int( con[1] )] := 1;
        conlin[set2int( con[2] )] := -1;
        Append( ShOB[1], [ conlin ] );
        Append( ShOB[2], [ 0 ] );
        Append( linrows, [ i ] );
        i := i + 1;
    od;
    conlin := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 ] );
    for j  in [ 1 .. ncinstance[2] ]  do
        conlin[set2int( [ j ] )] := 1;
    od;
    conlin[set2int( [ 1 .. ncinstance[2] ] )] := -1;
    Append( ShOB[1], [ conlin ] );
    Append( ShOB[2], [ 0 ] );
    Append( linrows, [ i ] );
    i := i + 1;
    for j  in [ 1 .. Size( ShOB[1] ) ]  do
        ShOB[1][j] := Concatenation( ZeroMutable( [ 1 .. ncinstance[3] ] ), ShOB[1][j] );
    od;
    for j  in [ 1 .. ncinstance[2] ]  do
        conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := 1;
        conineq[ncinstance[3] + set2int( [ j ] )] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
        conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
    od;
    for j  in [ ncinstance[2] + 1 .. ncinstance[3] ]  do
        conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        conineq[ncinstance[3] + set2int( [ j ] )] := 1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
        conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
        conineq[j] := -1;
        Append( ShOB[1], [ conineq ] );
        Append( ShOB[2], [ 0 ] );
    od;
    conineq := ZeroMutable( [ 1 .. 2 ^ ncinstance[3] - 1 + ncinstance[3] ] );
    for j  in [ 1 .. ncinstance[3] ]  do
        conineq[j] := 1;
    od;
    Append( ShOB[1], [ conineq ] );
    Append( ShOB[2], [ 1 ] );
    return [ ShOB[1], ShOB[2], linrows ];
end;


############################################################################## One time projection
NCRateRegionOB_decomposition := function ( ncinstance, N1,N2,N3, optargs ) #Calculate rate region from \Gamma_{N1\cup N3}\time \Gamma_{N2\cup N3}
    local  rlist, A, b, linrows, G, rlist1, ineq, ineqorb, row, rrA, rrb, onemap,
    nslist, idx, nsrec, los, lolos, Oi, O, trans_ineq;
    rlist := NCShannonBounded_decomposition( ncinstance, N1,N2,N3 );
    A := rlist[1];
    A := RemovezeroColumn(A);
    b := rlist[2];
    linrows := rlist[3];
    G := Group( [ () ] );
    if Size( optargs ) > 0  then
        nslist := [  ];
        nsrec := optargs[1];
        for idx  in RecNamesInt( nsrec )  do
            lolos := nsrec.(idx);
            for los  in lolos  do
                if idx = 1  then
                    ineq := ZYNonShannon( los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                else
                    ineq := DFZNonShannon( idx - 1, los, ncinstance[3] );
                    ineqorb := Orbit( G, ineq, OnEntropySpace );
                    Append( nslist, ineqorb );
                fi;
            od;
        od;
        Append( A, nslist );
        Append( b, ZeroMutable( [ 1 .. Size( nslist ) ] ) );
    fi;
    rlist1 := symCHM( A, b, linrows, ncinstance[3], G, OnProjPts, OnProjIneq, false );
    Display( Concatenation( "stats:  No. of LPs solved = ", String( rlist1[3][1] ),
       ", \n\t No. of facets = ", String( Size( rlist1[2] ) ),
       ", \n\tDD stepsizes beyond initial hull = ", String( rlist1[3][2] ) ) );
    rrA := [  ];
    rrb := [  ];
    for row  in rlist1[2]  do
        onemap := function ( x )
              return 1;
          end;
        if not row = List( [ 1 .. Size( row ) ], onemap )  then
            Append( rrA, [ row{[ 1 .. Size( row ) - 1 ]} ] );
            Append( rrb, [ row[Size( row )] ] );
        fi;
    od;
    trans_ineq := [  ];
    Oi := OrbitsDomain( G, rrA, OnProjIneq );
    for O  in Oi  do
        Append( trans_ineq, [ O[1] ] );
    od;
    return [ trans_ineq, RRparse( ncinstance, trans_ineq ) ];
end;

# ncinstance:=[[[[1,2],[1,2,4]],[[2,3],[2,3,5]],[[4,5],[4,5,6]],[[5],[5,7]],[[6,7],[6,7,8]],[[7],[7,9]],[[8,9],[8,9,10]],[[9],[9,11]],[[10],[3,10]],[[10,11],[1,2,10,11]]],3,11];
# N1 :=[1,2,3,10,11]; N2:=[6,7]; N3:=[4,5,8,9];
#  N1:=[4,5,6]; N2:=[9,10,11]; N3:=[1,2,3,7,8];
#rlsitOneTime := NCRateRegionOB_decomposition(ncinstance, N1,N2,N3,[]);
############################################################################################ 3-time projection
Permute_matrix_parallel:=function(B,A)
	local Bt,Bf,A1;
	Bt:=TransposedMat(B);
	Bt:=ShallowCopy(Bt);
	A1:=ShallowCopy(A);
	SortParallel(A1,Bt);
	Bf:=TransposedMat(Bt);
	return [Bf,A1];
end;


Permute_marginalAndJoin:=function(numofVar,listofedge) #subfunction
####example listofedge:=[[1],[2],[3],[4],[5],[6],[3,6],[5,6]]; permute column indices of A such that the first 7 indices are [1],..[6],[3,6],[5,6]
	local A,Len_LOE,i;
	Len_LOE:=Size(listofedge);
	A:=[Len_LOE+1..Len_LOE+2^(numofVar)-1];

	for i in [1..Len_LOE] do
		A[set2int(listofedge[i])]:=i;
	od;
	return A;
end;

AddconstraintsTopAndBottom_noindep:=function(ncinstancetop)
	local linrows,i,ShOB1,con,j,conlin;
	ShOB1 := GenShannonUnBounded( ncinstancetop[3] );
	i := Size( ShOB1[1] ) + 1;
	linrows := [  ];
	for con  in ncinstancetop[1]  do     #### H(Out(t),In(t))=H(In(t))
		conlin := ZeroMutable( [ 1 .. 2 ^ ncinstancetop[3] - 1 ] );
		conlin[set2int( con[1] )] := 1;
		conlin[set2int( con[2] )] := -1;
		Append( ShOB1[1], [ conlin ] );
		Append( ShOB1[2], [ 0 ] );
		Append( linrows, [ i ] );
		i := i + 1;
	od;
	conlin := ZeroMutable( [ 1 .. 2 ^ ncinstancetop[3] - 1 ] );
	return [ShOB1[1],ShOB1[2],linrows];
end;

AddconstraintsTopAndBottom_indep:=function(ncinstancetop)
	local linrows,i,ShOB1,con,j,conlin;
	ShOB1 := GenShannonUnBounded( ncinstancetop[3] );
	i := Size( ShOB1[1] ) + 1;
	linrows := [  ];
	for con  in ncinstancetop[1]  do     #### H(Out(t),In(t))=H(In(t))
		conlin := ZeroMutable( [ 1 .. 2 ^ ncinstancetop[3] - 1 ] );
		conlin[set2int( con[1] )] := 1;
		conlin[set2int( con[2] )] := -1;
		Append( ShOB1[1], [ conlin ] );
		Append( ShOB1[2], [ 0 ] );
		Append( linrows, [ i ] );
		i := i + 1;
	od;
	conlin := ZeroMutable( [ 1 .. 2 ^ ncinstancetop[3] - 1 ] );
	if ncinstancetop[2]>1 then
		for j  in [ 1 .. ncinstancetop[2] ]  do    #### H(s1,s2,..,sj)=H(s1)+H(s2)+,...,+H(sj)
			conlin[set2int( [ j ] )] := 1;
		od;
		conlin[set2int( [ 1 .. ncinstancetop[2] ] )] := -1;
		Append( ShOB1[1], [ conlin ] );
		Append( ShOB1[2], [ 0 ] );
		Append( linrows, [ i ] );
		i := i + 1;
	fi;
	return [ShOB1[1],ShOB1[2],linrows];
end;

ProjectOntoUseful_Var:=function(SH_P,Sb1,numofVar,linrows)
	local proj_SH,proj_Sb,conlin,j,G,rlist;
	proj_SH:=ShallowCopy(SH_P);
	proj_Sb:=ShallowCopy(Sb1);
	for j in [1..Size(SH_P[1])] do  # x >= 0
		conlin := ZeroMutable( [ 1 .. Size(SH_P[1]) ] );
		conlin[j] := -1;
		Append( proj_SH, [ conlin ] );
		Append( proj_Sb, [ 0 ] );
	od;

	conlin := ZeroMutable( [ 1 .. Size(SH_P[1]) ] );
	for j  in [ 1 .. numofVar ]  do    #### sum<=1
	conlin[j] :=1;
	od;
	Append( proj_SH, [ conlin ] );
	Append( proj_Sb, [  1 ] );
	G := Group( [ () ] );
	rlist := symCHM( proj_SH, proj_Sb, linrows, numofVar, G, OnProjPts, OnProjIneq, false );
	return rlist;
end;

#ncinstancetop:=[[ [[8],[3,8]], [[8,9],[1,2,8,9]] ],3,9];
#listofedge_top:=[[1],[2],[3],[4],[5],[6],[7],[8],[9],[1,2,4],[1,3,5],[4,5],[6,7],[6,7,8],[7,9]]; #[1,2],[1,3] has equalities
#numofVar:=9;


SHLT:=AddconstraintsTopAndBottom_indep(ncinstancetop);;
AAT:=Permute_marginalAndJoin(numofVar,listofedge_top);;
SHTA:=Permute_matrix_parallel(SHLT[1],AAT);;
SHT_P:=SHTA[1];;
SbT:=SHLT[2];;
A1:=SHTA[2];;
linrowsT:=SHLT[3];;
rlistTop:=ProjectOntoUseful_Var(SHT_P,SbT,Length(listofedge_top),linrowsT);


